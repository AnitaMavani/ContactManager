{"ast":null,"code":"import { fieldValidationRules } from './ValidationRules';\nconst Validation = inputs => {\n  const errors = Object.keys(inputs).reduce((acc, key) => {\n    const value = inputs[key];\n    const rules = fieldValidationRules[key];\n    const keyName = key.charAt(0).toUpperCase() + key.slice(1);\n    if (!rules) {\n      // Skip validation if no rules are defined for the key\n      console.log(\"skip the validation\");\n      return acc;\n    }\n    if (rules.required && !value.trim()) {\n      acc[key] = `${keyName} is required`;\n    } else if (rules.minLength && value.length < rules.minLength) {\n      acc[key] = `${keyName} must be at least ${rules.minLength} characters long`;\n    } else if (rules.regex && !rules.regex.test(value)) {\n      acc[key] = \"Invalid format\";\n    } else if (rules.customValidation) {\n      const customError = rules.customValidation(value, inputs);\n      if (customError) {\n        acc[key] = customError;\n      }\n    }\n    return acc;\n  }, {});\n  return errors;\n};\n_c = Validation;\nexport default Validation;\nvar _c;\n$RefreshReg$(_c, \"Validation\");","map":{"version":3,"names":["fieldValidationRules","Validation","inputs","errors","Object","keys","reduce","acc","key","value","rules","keyName","charAt","toUpperCase","slice","console","log","required","trim","minLength","length","regex","test","customValidation","customError","_c","$RefreshReg$"],"sources":["/Users/anitamavani/workspace/React/my-ts-app/src/pages/Validation.tsx"],"sourcesContent":["import {fieldValidationRules} from './ValidationRules';\n\ntype ValidationFunction<T> = (inputs: T) => Record<keyof T, string>;\n\nconst Validation = (inputs:Record<string, any> ) => {\n  \n  const errors = Object.keys(inputs).reduce((acc, key) => {\n    const value = inputs[key];\n    const rules = fieldValidationRules[key];\n    const keyName = key.charAt(0).toUpperCase()+ key.slice(1);\n    \n    if (!rules) {\n      // Skip validation if no rules are defined for the key\n      console.log(\"skip the validation\");\n      return acc;\n    }\n\n    if (rules.required && !value.trim()) {\n      acc[key] = `${keyName} is required`;\n    } else if (rules.minLength && value.length < rules.minLength) {\n      acc[key] = `${keyName} must be at least ${rules.minLength} characters long`;\n    } else if (rules.regex && !rules.regex.test(value)) {\n      acc[key] = \"Invalid format\";\n    } else if (rules.customValidation) {\n      const customError = rules.customValidation(value, inputs);\n      if (customError) {\n        acc[key] = customError;\n      }\n    }\n    return acc;\n  }, {} as Record<string, string>);\n  return errors;\n};\n\nexport default Validation;\n"],"mappings":"AAAA,SAAQA,oBAAoB,QAAO,mBAAmB;AAItD,MAAMC,UAAU,GAAIC,MAA0B,IAAM;EAElD,MAAMC,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,CAACI,MAAM,CAAC,CAACC,GAAG,EAAEC,GAAG,KAAK;IACtD,MAAMC,KAAK,GAAGP,MAAM,CAACM,GAAG,CAAC;IACzB,MAAME,KAAK,GAAGV,oBAAoB,CAACQ,GAAG,CAAC;IACvC,MAAMG,OAAO,GAAGH,GAAG,CAACI,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC,GAAEL,GAAG,CAACM,KAAK,CAAC,CAAC,CAAC;IAEzD,IAAI,CAACJ,KAAK,EAAE;MACV;MACAK,OAAO,CAACC,GAAG,CAAC,qBAAqB,CAAC;MAClC,OAAOT,GAAG;IACZ;IAEA,IAAIG,KAAK,CAACO,QAAQ,IAAI,CAACR,KAAK,CAACS,IAAI,CAAC,CAAC,EAAE;MACnCX,GAAG,CAACC,GAAG,CAAC,GAAG,GAAGG,OAAO,cAAc;IACrC,CAAC,MAAM,IAAID,KAAK,CAACS,SAAS,IAAIV,KAAK,CAACW,MAAM,GAAGV,KAAK,CAACS,SAAS,EAAE;MAC5DZ,GAAG,CAACC,GAAG,CAAC,GAAG,GAAGG,OAAO,qBAAqBD,KAAK,CAACS,SAAS,kBAAkB;IAC7E,CAAC,MAAM,IAAIT,KAAK,CAACW,KAAK,IAAI,CAACX,KAAK,CAACW,KAAK,CAACC,IAAI,CAACb,KAAK,CAAC,EAAE;MAClDF,GAAG,CAACC,GAAG,CAAC,GAAG,gBAAgB;IAC7B,CAAC,MAAM,IAAIE,KAAK,CAACa,gBAAgB,EAAE;MACjC,MAAMC,WAAW,GAAGd,KAAK,CAACa,gBAAgB,CAACd,KAAK,EAAEP,MAAM,CAAC;MACzD,IAAIsB,WAAW,EAAE;QACfjB,GAAG,CAACC,GAAG,CAAC,GAAGgB,WAAW;MACxB;IACF;IACA,OAAOjB,GAAG;EACZ,CAAC,EAAE,CAAC,CAA2B,CAAC;EAChC,OAAOJ,MAAM;AACf,CAAC;AAACsB,EAAA,GA5BIxB,UAAU;AA8BhB,eAAeA,UAAU;AAAC,IAAAwB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}